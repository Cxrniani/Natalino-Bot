# Desenvolvimento da aplica√ß√£o Natalino Bot

<!-- Terminar links-->
## üë®‚Äçüíª Projeto desenvolvido por: [Felipe Pellissari](https://github.com/FeliPellissari), [J√∫lia Campos Nery](https://github.com/juliacamposn), [Lorena Valente Cavalheiro](https://github.com/Lorena-Valente-Cavalheiro), [Matheus Corniani](https://github.com/Cxrniani), [Rafael Torres Nantes](https://github.com/rafael-torres-nantes) e [Sarah Baraldi](https://github.com/mbaraldi-sarah).

## √çndice

* [üìö Contextualiza√ß√£o do projeto](#-contextualiza√ß√£o-do-projeto)
* [üõ†Ô∏è Tecnologias/Ferramentas utilizadas](#%EF%B8%8F-tecnologiasferramentas-utilizadas)
* [üñ•Ô∏è Funcionamento do sistema](#%EF%B8%8F-funcionamento-do-sistema)
   * [üí¨ Parte 1 - Chatbot](#-parte-1---chatbot)
   * [üöÇ Parte 2 - Reconhecimento de imagens](#-parte-2---reconhecimento-de-objetos)
   * [üìù Inserindo logs no DynamoDB](#%EF%B8%8F-inserindo-logs-no-dynamodb)
   * [üîÄ Arquitetura da aplica√ß√£o](#em-resumo-o-fluxo-da-aplica√ß√£o-se-d√°-da-seguinte-forma)
* [üìÅ Estrutura do projeto](#-estrutura-do-projeto)
* [üìå Como executar o projeto](#-como-executar-o-projeto)
* [üïµÔ∏è Dificuldades Encontradas](#%EF%B8%8F-dificuldades-encontradas)

<!--* [üîó Endpoints](#-endpoints)-->

## üìö Contextualiza√ß√£o do projeto

O projeto tem o objetivo de **otimizar** e **automatizar** a comunica√ß√£o e organiza√ß√£o da a√ß√£o social [**Natal dos Pequenos**](https://www.instagram.com/natal_dos_pequenos).

A a√ß√£o consiste em **arrecadar** brinquedos, roupas, entre outros objetos, e/ou valores em dinheiro para a compra destes e **do√°-los** a crian√ßas em situa√ß√£o de vulnerabilidade social.

As doa√ß√µes de objetos s√£o feitas diretamente para a equipe respons√°vel pela a√ß√£o ou em caixas espalhadas, geralmente, pela **Universidade Federal do Mato Grosso do Sul**. J√° as doa√ß√µes em dinheiro s√£o feitas via **pix**.

Para otimizar as doa√ß√µes, nossa equipe ir√° desenvolver um ***chatbot* humanizado** para o *Telegram* utilizando ***Amazon Lex***, ***Amazon Bedrock*** e ***Amazon Transcribe***. 

O *chatbot* informar√° sobre as **formas** de doa√ß√£o, **localiza√ß√£o** das caixas, chaves **pix** e etc. Al√©m disso, os doadores poder√£o enviar **fotos** dos objetos que desejam doar e o *bot* comunicar√° se os brinquedos est√£o em **boas** ou **m√°s condi√ß√µes**.

Para fazer o reconhecimento dos objetos e seus estados de conserva√ß√£o, vamos utilizar o ***Amazon Rekognition*** e armazenaremos as imagens no ***AWS S3*** j√° classificadas como boas ou avariadas.

Al√©m disso, armazenaremos *logs* no ***Amazon DynamoDB*** referentes aos objetos contendo suas caracter√≠sticas, seu estado de conserva√ß√£o.


## üõ†Ô∏è Tecnologias/Ferramentas utilizadas

[<img src="https://img.shields.io/badge/Visual_Studio_Code-007ACC?">](https://code.visualstudio.com/)
[<img src="https://img.shields.io/badge/Git-232F3E?logo=git&logoColor=red">](https://git-scm.com/)
[<img src="https://img.shields.io/badge/GitHub-181717?logo=github&logoColor=violet">](https://github.com/)

[<img src="https://img.shields.io/badge/AWS-fda100?logo=amazon-web-services&logoColor=white">](https://aws.amazon.com/pt/)
[<img src="https://img.shields.io/badge/AWS-CLI-fa8818?logo=amazon-web-services&logoColor=fda100&labelColor=232F3E">](https://aws.amazon.com/pt/cli/)
[<img src="https://img.shields.io/badge/AWS-S3-dd2304?logo=amazon-web-services&logoColor=fda100&labelColor=232F3E">](https://aws.amazon.com/pt/s3/)
[<img src="https://img.shields.io/badge/Amazon-DynamoDB-4053D6?logo=amazon-web-services&logoColor=fda100&labelColor=232F3E">](https://aws.amazon.com/pt/pm/dynamodb/)
[<img src="https://img.shields.io/badge/Amazon-Bedrock-01ac71?logo=amazon-web-services&logoColor=fda100&labelColor=232F3E">](https://aws.amazon.com/pt/bedrock/)
[<img src="https://img.shields.io/badge/Amazon-Rekognition-2a7abc?logo=amazon-web-services&logoColor=fda100&labelColor=232F3E">](https://aws.amazon.com/pt/rekognition/)
[<img src="https://img.shields.io/badge/Amazon-Transcribe-03ab9d?logo=amazon-web-services&logoColor=fda100&labelColor=232F3E">](https://aws.amazon.com/pt/transcribe/)

[<img src="https://img.shields.io/badge/Serverless_Framework-ff5242?logo=serverless&logoColor=white">](https://www.serverless.com)

[<img src="https://img.shields.io/badge/Telegram-24A1DE?logo=Telegram&logoColor=white">](https://www.instagram.com/)


#### Organiza√ß√£o do Time:

[<img src="https://img.shields.io/badge/Teams-5864A6?">](https://www.microsoft.com/pt-br/microsoft-teams/group-chat-software)
[<img src="https://img.shields.io/badge/Trello-0079BF?logo=trello&logoColor=white">](https://trello.com/)
[<img src="https://img.shields.io/badge/Whatsapp-25d366?logo=whatsapp&logoColor=white">](https://www.whatsapp.com/?lang=pt_BR)

## üñ•Ô∏è Funcionamento do sistema

### üí¨ Parte 1 - Chatbot

Em nosso projeto, desenvolvemos um *chatbot* para informar poss√≠veis doadores **sobre a a√ß√£o** e **como doar**.

O *bot* √© capaz de receber uma foto de um objeto para que seja **avaliado** se est√° ou n√£o em condi√ß√µes de ser doado. Al√©m de informar como fazer a **doa√ß√£o por pix**.

A rela√ß√£o entre os *intents* e seus *slots* est√° descrita na tabela abaixo:

| Intent                 | Slots                    |
|------------------------|-------------------------| 
| IntentApresentacao     | --                       |
| IntentDoar             | TipoDoacao               | 
| IntentInfo             | TipoInfo                 | 
| FallbackIntent         | --              |

Sendo assim, o fluxo de conversa do *chatbot* se d√° por:

![Diagrama de Arquitetura](assets/fluxo_conversacao_lex.png)

O chatbot conta com recursos do ***Amazon Bedrock*** e ***AWS Transcribe*** para se tornar mais humanizado.

#### Amazon Bedrock

O ***Amazon Bedrock*** √© o respond√°vel por criar mensagens amig√°veis e humanizadas para o **Fallback**, assim como interpretar o texto transcrito de √°udios recebidos, identificando a inten√ß√£o do usu√°rio.

<!-- Exemplo Terminar-->

#### AWS Transcribe

O ***AWS Transcribe*** permite que o poss√≠vel doador mande √°udio para o *bot*. O √°udio √© transcrito pela ferramenta e enviado ao *bot* como se fosse uma mensagem de texto. 

<!-- Exemplo Terminar-->

### üöÇ Parte 2 - Reconhecimento de Imagens

O reconhecimento de imagens √© feito pelo Amazon Rekognition. Se concentrando em duas fun√ß√µes, *detect_labels* e *detect_text*:

- A fun√ß√£o *detect_labels* √© a principal, reconhecendo imagens e retornando *labels*.

```py
def detect_labels(self, bucket, image_name):
    """
    Detecta r√≥tulos em uma imagem armazenada em um bucket do S3.

    :param bucket: Nome do bucket do S3 onde a imagem est√° armazenada.
    :param image_name: Nome do arquivo de imagem no bucket do S3.
    :return: Resposta da API detect_labels do Amazon Rekognition.
    """
    try:
        # Chama a API detect_labels do Amazon Rekognition
        response = self.rekognition.detect_labels(
            Image={
                'S3Object': {
                    'Bucket': bucket,
                    'Name': image_name
                }
            },
            MaxLabels=10,
            MinConfidence=80,
            Features=["GENERAL_LABELS", "IMAGE_PROPERTIES"],
            Settings={"ImageProperties": {"MaxDominantColors": 10}}
        )
        return response
    
    except BotoCoreError as e:
        # Em caso de erro, imprime a mensagem de erro e retorna None
        print(f"Erro ao detectar r√≥tulos: {e}")
        return None
``` 

- Ap√≥s a detec√ß√£o inicial, **filtramos** as *labels* pra verificar a necessidade de usarmos a *detect_text*.

```py
def filter_rekogntion_labels(self, rekogntion_labels):
    """
    Filtra e atualiza os labels detectados com informa√ß√µes adicionais, se necess√°rio.

    Parameters:
        rekogntion_labels (dict): Labels detectados pela fun√ß√£o Rekognition.

    Returns:
        dict: Labels atualizados com informa√ß√µes adicionais, se necess√°rio.
    """
    # Detectando textos na imagem
    if 'Page' in rekogntion_labels['item_name'] or 'Text and Documents' in rekogntion_labels['Categories']:
        response_text = self.rekognition_service.detect_text(self.api_bucket, self.object_name)
        info_text = extract_text_data_from_rekognition(response_text)
        rekogntion_labels['donation_type'] = info_text['donation_type']
        rekogntion_labels['donation_value'] = info_text['donation_value']

    # Atualiza o estado de conserva√ß√£o se detectado
    if 'Damage Detection' in rekogntion_labels['Categories']:
        rekogntion_labels['conservation_state'] = 'bad state'
    
    return rekogntion_labels
```

- Caso dentre as *labels* iniciais houver "*Text and Documents*", utilizamos a fun√ß√£o *detect_text*. Essa fun√ß√£o √© utilizada para ler os **comprovantes de pix**:

```py
def detect_text(self, bucket, image_name):
    """
    Detecta texto em uma imagem armazenada em um bucket do S3.

    :param bucket: Nome do bucket do S3 onde a imagem est√° armazenada.
    :param image_name: Nome do arquivo de imagem no bucket do S3.
    :return: Lista de detec√ß√µes de texto na imagem.
    """
    try:
        # Chama a API detect_text do Amazon Rekognition
        response = self.rekognition.detect_text(
            Image={
                'S3Object': {
                    'Bucket': bucket,
                    'Name': image_name
                }
            }
        )

        # Obt√©m as detec√ß√µes de texto da resposta
        textDetections = response['TextDetections']
        return textDetections
    
    except BotoCoreError as e:
        # Em caso de erro, imprime a mensagem de erro e retorna None
        print(f"Erro ao detectar texto: {e}")
        return None
```

Ao final das detec√ß√µes armeazenamos as imagens em um *bucket* ***S3***.

<!-- Terminar -->

### üìù Inserindo logs no DynamoDBS

### Em resumo, o fluxo da aplica√ß√£o se d√° da seguinte forma:

![Diagrama de Arquitetura](assets/AWSArchitectureDiagramming.png)

## üìÅ Estrutura do projeto 

#### O projeto foi dividido nos seguintes diret√≥rios, baseando-se no modelo MVC (Model-View-Controller) com devidas adapta√ß√µes:

```
‚îî‚îÄ‚îÄ üìÅ sprints-9-10-pb-aws-marco
    ‚îî‚îÄ‚îÄ üìÅ assets 
    ‚îî‚îÄ‚îÄ üìÅ src
        ‚îî‚îÄ‚îÄ üìÅ controller
            ‚îî‚îÄ‚îÄ app_controller.py
        ‚îî‚îÄ‚îÄ üìÅ services
            ‚îî‚îÄ‚îÄ s3_service.py
            ‚îî‚îÄ‚îÄ dynamodb_service.py
            ‚îî‚îÄ‚îÄ rekognition_service.py
            ‚îî‚îÄ‚îÄ bedrock_service.py
        ‚îî‚îÄ‚îÄ üìÅ utils
            ‚îî‚îÄ‚îÄ utils.js
        ‚îî‚îÄ‚îÄ handler.py
        ‚îî‚îÄ‚îÄ requirements.txt
        ‚îî‚îÄ‚îÄ serverless.yml    
    ‚îî‚îÄ‚îÄ README
```

#### Divis√£o dos diret√≥rios:

- `controller` ‚Üí Realizam a chamada dos *services* (em ./services) criados para gerenciar os servi√ßos AWS.

- `services` ‚Üí Manipulam os servi√ßos AWS.

- `utils` ‚Üí Arquivos de utilidades, usados para checagem, testes e etc.

#### Outros arquivos importantes:

- `handler.py` ‚Üí Cont√©m as fun√ß√µes que sintetizam a API e define suas rotas. Verifica a sa√∫de da API, recebe imagem e retorna os detalhes do reconhecimento do **Amazon Rekognition**.

- `serverless.yml` ‚Üí Define as pol√≠ticas **IAM** para permitir que as **fun√ß√µes Lambda** acessem os servi√ßos necess√°rios e rotas das requisi√ß√µes que ser√£o usadas no *handler.py*. 


## üìå Como executar o projeto

### Clone o reposit√≥rio

```bash
$ git clone https://github.com/Compass-pb-aws-2024-MARCO/sprints-9-10-pb-aws-marco.git 
```

### Acesse a pasta do projeto no terminal/cmd:

```bash
$ cd sprints-8-pb-aws-marco
```

### Realize um check-out para a branch de desenvolvimento:

```bash
$ git checkout grupo-03
```

### Cerfitique-se ue tem o serverless instalado:

```bash
$ serverless
```

### Caso n√£o estiver, instale poe meio do comando:

```bash
$ npm install -g serverless
```

### Instale os plugins do serverless:

```bash
$ npm install serverless-python-requirements serverless-dotenv-plugin
```

### Configure as credenciais da aws:

```bash
$ aws configure
```

### Fa√ßa login no serverless:

```bash
$ serverless login
```

<!-- Terminar -->

<!--
### Acesse a pasta visao-computacional:

```bash
$ cd visao-computacional
```

### Execute o seguinte comando para realizar o deploy:
```bash
$ serverless deploy
```
-->

<!--
## üîó Links de Teste

### Endpoints:


üî∏ **GET** - https://fbpdfs3097.execute-api.us-east-1.amazonaws.com/

üî∏ **GET** - https://fbpdfs3097.execute-api.us-east-1.amazonaws.com/v1

üî∏ **GET** - https://fbpdfs3097.execute-api.us-east-1.amazonaws.com/v2

üîπ **POST** - https://fbpdfs3097.execute-api.us-east-1.amazonaws.com/v1/vision

üîπ **POST** - https://fbpdfs3097.execute-api.us-east-1.amazonaws.com/v2/vision

-->


## üïµÔ∏è Dificuldades Encontradas

### ‚öô Dificuldades T√©cnicas

A integra√ß√£o dos servi√ßos AWS causou nossas maiores dificuldades. Algumas ainda n√£o foram totalmente resolvidas.

<!-- Terminar -->

### üìù Dificuldades de Organiza√ß√£o

<!-- Terminar  -->
